package main

import (
	"encoding/json"
	"fmt"
	"net/http"
	"regexp"
	"strings"

	"github.com/gitpod-io/gitbot/common"
	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/util/sets"
	prowgithub "k8s.io/test-infra/prow/github"
)

var (
	commentRegex            = regexp.MustCompile(`(?s)<!--(.*?)-->`)
	genericLabelRegex       = regexp.MustCompile(`(?m)^/label\s*(.*?)\s*$`)
	genericRemoveLabelRegex = regexp.MustCompile(`(?m)^/remove-label\s*(.*?)\s*$`)
)

const readmeURL = "https://github.com/gitpod-io/gitbot/blob/main/plugins/customlabels/README.md"

type server struct {
	tokenGenerator       func() []byte
	githubTokenGenerator func() []byte
	gh                   prowgithub.Client
	log                  *logrus.Entry
	cfg                  Config
	repoMatchers         map[string]Matchers
	// repos -> { "<key>: <value>", ... }
	repoValidLabels map[string]sets.String
}

func (s *server) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	eventType, eventGUID, payload, ok, code := prowgithub.ValidateWebhook(w, r, s.tokenGenerator)
	if !ok {
		s.log.WithField("status code", code).Error("Error validating webhook")
		return
	}
	// Event received, handle it
	if err := s.handleEvent(eventType, eventGUID, payload); err != nil {
		s.log.WithError(err).Error("Error parsing event")
	}
}

func (s *server) handleEvent(eventType, eventGUID string, payload []byte) error {
	l := s.log.WithFields(logrus.Fields{
		"event-type":         eventType,
		prowgithub.EventGUID: eventGUID,
	})

	switch eventType {
	case "issue_comment":
		var evt prowgithub.IssueCommentEvent
		if err := json.Unmarshal(payload, &evt); err != nil {
			s.log.WithError(err).WithFields(l.Data).Error("Error unmarshaling event")
			return err
		}
		go func() {
			if err := s.handleIssueCommentEvent(&evt); err != nil {
				s.log.WithError(err).WithFields(l.Data).Info("Error handling event")
			}
		}()
	case "issues":
		var evt prowgithub.IssueEvent
		if err := json.Unmarshal(payload, &evt); err != nil {
			s.log.WithError(err).WithFields(l.Data).Error("Error unmarshaling event")
			return err
		}
		go func() {
			if err := s.handleIssueEvent(&evt); err != nil {
				s.log.WithError(err).WithFields(l.Data).Info("Error handling event")
			}
		}()
	case "pull_request":
		var evt prowgithub.PullRequestEvent
		if err := json.Unmarshal(payload, &evt); err != nil {
			s.log.WithError(err).WithFields(l.Data).Error("Error unmarshaling event")
			return err
		}
		go func() {
			if err := s.handlePullRequestEvent(&evt); err != nil {
				s.log.WithError(err).WithFields(l.Data).Info("Error handling event")
			}
		}()
	default:
		s.log.WithFields(l.Data).Debugf("Skipping event")
	}
	return nil
}

func (s *server) handleIssueCommentEvent(evt *prowgithub.IssueCommentEvent) error {
	switch evt.Action {
	case prowgithub.IssueCommentActionCreated:
		fallthrough
	case prowgithub.IssueCommentActionEdited:
		return s.handle(false, evt.Issue.Number, evt.Comment.Body, evt.Repo, evt.Comment.HTMLURL, evt.Comment.User.Login)
	default:
		s.log.WithField("action", evt.Action).Debug("Skipping event")
	}

	return nil
}

func (s *server) handleIssueEvent(evt *prowgithub.IssueEvent) error {
	switch evt.Action {
	case prowgithub.IssueActionEdited:
		fallthrough
	case prowgithub.IssueActionOpened:
		return s.handle(false, evt.Issue.Number, evt.Issue.Body, evt.Repo, evt.Issue.HTMLURL, evt.Issue.User.Login)
	default:
		s.log.WithField("action", evt.Action).Debug("Skipping event")
	}
	return nil
}

func (s *server) handlePullRequestEvent(evt *prowgithub.PullRequestEvent) error {
	switch evt.Action {
	case prowgithub.PullRequestActionOpened:
		fallthrough
	case prowgithub.PullRequestActionEdited:
		return s.handle(true, evt.Number, evt.PullRequest.Body, evt.Repo, evt.PullRequest.HTMLURL, evt.PullRequest.User.Login)
	default:
		s.log.WithField("action", evt.Action).Debug("Skipping event")
	}
	return nil
}

func (s *server) handle(isPR bool, num int, body string, repo prowgithub.Repo, htmlUrl string, opener string) error {
	// ATTENTION
	// Events generated by the bot itself MUST be ignored to avoid self loops.
	// TODO > make the bot GitHub name configurable
	if opener == "roboquat" {
		return nil
	}

	// Remove comments from the body
	bodyWithoutComments := commentRegex.ReplaceAllString(body, "")

	// Select regular expressions depending on the current repository
	labelRegex := s.repoMatchers[repo.FullName].LabelRegex
	if labelRegex == nil {
		return fmt.Errorf("missing regular expression to match the addition of labels")
	}
	removeLabelRegex := s.repoMatchers[repo.FullName].RemoveLabelRegex
	if removeLabelRegex == nil {
		return fmt.Errorf("missing regular expression to match the deletion of labels")
	}

	// Search for specific matches like /<key> <target> and /remove-<key> <target>
	labelMatches := labelRegex.FindAllStringSubmatch(bodyWithoutComments, -1)
	s.log.WithField("matches", labelMatches).Debug("matches for label addition")
	removeLabelMatches := removeLabelRegex.FindAllStringSubmatch(bodyWithoutComments, -1)
	s.log.WithField("matches", removeLabelMatches).Debug("matches for label deletion")

	// Search for generic /label <target> and /remove-label <target> matches
	genericLabelMatches := genericLabelRegex.FindAllStringSubmatch(bodyWithoutComments, -1)
	genericRemoveLabelMatches := genericRemoveLabelRegex.FindAllStringSubmatch(bodyWithoutComments, -1)

	// Is this an issue or a pull request?
	what := "issue"
	if isPR {
		what = "pull request"
	}

	org := repo.Owner.Login
	reponame := repo.Name
	existent := s.repoValidLabels[repo.FullName]

	if len(labelMatches) == 0 && len(removeLabelMatches) == 0 && len(genericLabelMatches) == 0 && len(genericRemoveLabelMatches) == 0 {
		s.log.WithField("body", bodyWithoutComments).Info("No match found")

		msg := fmt.Sprintf("These are the supported labels: `%s`", strings.Join(existent.List(), ", "))

		return s.gh.CreateComment(org, reponame, num, common.FormatResponseRaw(bodyWithoutComments, htmlUrl, opener, msg, readmeURL))
	}

	repoLabels, err := s.gh.GetRepoLabels(org, reponame)
	if err != nil {
		return err
	}

	var labels []prowgithub.Label
	if isPR {
		pullreq, err := s.gh.GetPullRequest(org, reponame, num)
		if err != nil {
			return err
		}
		labels = pullreq.Labels
	} else {
		labels, err = s.gh.GetIssueLabels(org, reponame, num)
		if err != nil {
			return err
		}
	}

	existingRepoLabels := sets.String{}
	for _, l := range repoLabels {
		existingRepoLabels.Insert(strings.ToLower(l.Name))
	}

	// Support variables
	var nonexistent []string
	var noSuchLabelsOnIssue []string

	// Get labels to add and labels to remove
	labelsToAdd := append(getLabelsFromMatches(labelMatches, existent, &nonexistent), getLabelsFromGenericMatches(genericLabelMatches, existent, &nonexistent)...)
	labelsToRemove := append(getLabelsFromMatches(removeLabelMatches, existent, &nonexistent), getLabelsFromGenericMatches(genericRemoveLabelMatches, existent, &nonexistent)...)

	// Add labels
	for _, addition := range labelsToAdd {
		if prowgithub.HasLabel(addition, labels) {
			s.log.WithField("label", addition).Debug("Label already present: nothing to add")
			continue
		}

		if !existingRepoLabels.Has(addition) {
			s.log.WithField("label", addition).WithField("repo", repo.FullName).Debug("missing label: adding it to the repository")
			if err := s.gh.AddRepoLabel(org, reponame, addition, "", common.RandStringBytesMaskImprSrc(6)); err != nil {
				s.log.WithError(err).WithField("label", addition).WithField("repo", repo.FullName).Debug("Failure creating label")
				continue
			}
		}

		// NOTE > implement here custom access control depending on the user (`opener`)
		// Example: /type: <target> only available to user that are members of the org (need a field in the configuration)
		// if addition ==  ... { s.gh.IsMember(org, `opener`) ... }

		if err := s.gh.AddLabel(org, reponame, num, addition); err != nil {
			s.log.WithError(err).Errorf("GitHub failed to add the label to %s %s#%d", what, repo.FullName, num)
		}
	}

	// Remove labels
	for _, remove := range labelsToRemove {
		if !prowgithub.HasLabel(remove, labels) {
			s.log.WithField("label", remove).Info("Label not present: nothing to remove")
			noSuchLabelsOnIssue = append(noSuchLabelsOnIssue, remove)
			continue
		}

		if !existingRepoLabels.Has(remove) {
			s.log.WithField("label", remove).WithField("repo", repo.FullName).Debug("Missing label: repository does not have it")
			continue
		}

		// NOTE > implement here custom access control depending on the user (`opener`)

		if err := s.gh.RemoveLabel(org, reponame, num, remove); err != nil {
			s.log.WithError(err).Errorf("GitHub failed to remove the label from %s %s#%d", what, repo.FullName, num)
		}
	}

	if len(nonexistent) > 0 {
		s.log.Infof("Not existing labels: %v", nonexistent)

		msg := fmt.Sprintf("The label(s) `%s` cannot be applied. These labels are supported: `%s`", strings.Join(nonexistent, ", "), strings.Join(existent.List(), ", "))

		return s.gh.CreateComment(org, reponame, num, common.FormatResponseRaw(bodyWithoutComments, htmlUrl, opener, msg, readmeURL))
	}

	// The user tried to remove labels that were not present
	if len(noSuchLabelsOnIssue) > 0 {
		s.log.Infof("Not set: %v", noSuchLabelsOnIssue)

		msg := fmt.Sprintf("Those labels are not set on the %s: `%v`", what, strings.Join(noSuchLabelsOnIssue, ", "))

		return s.gh.CreateComment(org, reponame, num, common.FormatResponseRaw(bodyWithoutComments, htmlUrl, opener, msg, readmeURL))
	}

	return nil
}

// Get the labels from regexp matches
func getLabelsFromMatches(matches [][]string, valids sets.String, invalids *[]string) (labels []string) {
	for _, match := range matches {
		m := strings.TrimSpace(match[0])
		parts := strings.SplitN(m, " ", 2)[1:]
		logrus.WithField("label parts", parts).Debug("processing label match")
		for _, label := range parts {
			label = strings.ToLower(match[1] + ": " + strings.Trim(strings.TrimSpace(label), "\""))
			if valids.Has(label) {
				labels = append(labels, label)
			} else {
				*invalids = append(*invalids, label)
			}
		}
	}
	return
}

// Get the labels from generic matches
func getLabelsFromGenericMatches(matches [][]string, valids sets.String, invalids *[]string) []string {
	var labels []string
	for _, match := range matches {
		m := strings.TrimSpace(match[0])
		parts := strings.SplitN(m, " ", 2)
		if parts[0] != "/label" && parts[0] != "/remove-label" {
			continue
		}
		candidate := strings.ToLower(strings.Trim(strings.TrimSpace(parts[1]), "\""))
		if valids.Has(candidate) {
			labels = append(labels, candidate)
		} else {
			*invalids = append(*invalids, candidate)
		}
	}
	return labels
}
